<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chain Reaction - Free Online Multiplayer Strategy Game | Kaiross</title>

    <!-- SEO Meta Tags -->
    <meta name="description" content="Play Chain Reaction online - a strategic multiplayer board game with AI opponent. Capture cells, trigger chain reactions, and dominate the grid. Free to play, no download required.">
    <meta name="keywords" content="chain reaction game, online multiplayer game, strategy game, board game, puzzle game, AI game, free browser game, kaiross">
    <meta name="author" content="Kaiross">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://kaiross.in/chain-reaction">

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://kaiross.in/chain-reaction">
    <meta property="og:title" content="Chain Reaction - Free Online Multiplayer Strategy Game">
    <meta property="og:description" content="Play Chain Reaction online - a strategic multiplayer board game with AI opponent. Capture cells, trigger chain reactions, and dominate the grid.">
    <meta property="og:image" content="https://kaiross.in/chain-reaction/og-image.png">
    <meta property="og:site_name" content="Kaiross">

    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:url" content="https://kaiross.in/chain-reaction">
    <meta name="twitter:title" content="Chain Reaction - Free Online Multiplayer Strategy Game">
    <meta name="twitter:description" content="Play Chain Reaction online - a strategic multiplayer board game with AI opponent. Capture cells, trigger chain reactions, and dominate the grid.">
    <meta name="twitter:image" content="https://kaiross.in/chain-reaction/og-image.png">

    <!-- Additional SEO -->
    <meta name="theme-color" content="#0A84FF">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Chain Reaction">

    <!-- Structured Data -->
    <script type="application/ld+json">
    {
        "@context": "https://schema.org",
        "@type": "WebApplication",
        "name": "Chain Reaction",
        "url": "https://kaiross.in/chain-reaction",
        "description": "A strategic multiplayer board game with AI opponent. Capture cells, trigger chain reactions, and dominate the grid.",
        "applicationCategory": "GameApplication",
        "genre": "Strategy",
        "operatingSystem": "Any",
        "offers": {
            "@type": "Offer",
            "price": "0",
            "priceCurrency": "USD"
        },
        "author": {
            "@type": "Organization",
            "name": "Kaiross",
            "url": "https://kaiross.in"
        }
    }
    </script>

    <!-- Socket.io Client -->
    <script src="/socket.io/socket.io.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

        :root {
            --bg-color: #121212;
            --grid-line: #333;
            --text-color: #fff;
            --accent: #0A84FF;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Orbitron', sans-serif;
            overflow: hidden; /* Prevent scrolling on mobile */
            display: flex;
            flex-direction: column;
            height: 100vh;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        /* Header Area */
        #header {
            flex: 0 0 auto;
            display: flex;
            flex-direction: column;
            padding: 12px 16px;
            background: linear-gradient(180deg, rgba(30, 30, 30, 0.95) 0%, rgba(18, 18, 18, 0.98) 100%);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 10;
            gap: 12px;
            backdrop-filter: blur(10px);
        }

        .top-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .brand-section {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        h1 {
            font-size: 1.1rem;
            margin: 0;
            letter-spacing: 2px;
            background: linear-gradient(135deg, #fff 0%, var(--accent) 50%, #BF5AF2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(10, 132, 255, 0.3);
        }

        .action-buttons {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .controls-row {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        .settings-group {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 6px 10px;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        button {
            background: rgba(255, 255, 255, 0.08);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.15);
            padding: 8px 16px;
            border-radius: 20px;
            font-family: inherit;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 500;
            letter-spacing: 0.5px;
        }

        button:hover {
            background: rgba(255, 255, 255, 0.12);
            border-color: rgba(255, 255, 255, 0.25);
            transform: translateY(-1px);
        }

        button.primary {
            background: linear-gradient(135deg, var(--accent) 0%, #0066CC 100%);
            border: none;
            box-shadow: 0 4px 15px rgba(10, 132, 255, 0.3);
        }

        button.primary:hover {
            box-shadow: 0 6px 20px rgba(10, 132, 255, 0.4);
            transform: translateY(-2px);
        }

        button.icon-btn {
            padding: 8px 12px;
            font-size: 1rem;
            line-height: 1;
        }

        button:active {
            transform: scale(0.95) translateY(0);
        }

        select, input[type="text"] {
            background: rgba(0, 0, 0, 0.3);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 6px 10px;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        select:hover, input[type="text"]:hover {
            border-color: rgba(255, 255, 255, 0.2);
        }

        select:focus, input[type="text"]:focus {
            outline: none;
            border-color: var(--accent);
        }

        label {
            display: flex;
            align-items: center;
            gap: 6px;
            cursor: pointer;
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.8);
        }

        label input[type="checkbox"] {
            accent-color: var(--accent);
        }

        /* Game Container */
        #game-container {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        canvas {
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border: 1px solid #333;
            background-color: #1a1a1a;
            transition: border-color 0.5s ease;
        }

        /* Player Indicator Bar */
        #status-bar {
            flex: 0 0 50px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 16px;
            background: linear-gradient(180deg, rgba(18, 18, 18, 0.98) 0%, rgba(10, 10, 10, 1) 100%);
            font-size: 0.9rem;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            transition: border-color 0.3s ease;
        }

        .turn-indicator {
            display: flex;
            align-items: center;
        }

        .player-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 10px;
            box-shadow: 0 0 8px currentColor;
        }

        .brand-link {
            font-size: 0.65rem;
            color: rgba(255, 255, 255, 0.4);
            text-decoration: none;
            letter-spacing: 1px;
            transition: color 0.2s;
        }

        .brand-link:hover {
            color: var(--accent);
        }

        /* Modal */
        .modal {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: #1e1e1e;
            padding: 30px;
            border-radius: 10px;
            border: 1px solid #333;
            text-align: center;
            max-width: 90%;
            width: 350px;
        }

        .modal h2 {
            font-size: 1.5rem;
            margin-bottom: 20px;
            text-transform: uppercase;
            color: var(--accent);
        }

        .modal-btn-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-btn-group button {
            padding: 12px;
            font-size: 1rem;
        }

        .room-code-display {
            font-size: 2rem;
            letter-spacing: 5px;
            font-weight: bold;
            margin: 20px 0;
            color: #fff;
            background: #000;
            padding: 10px;
            border-radius: 5px;
        }

        .room-input {
            padding: 10px;
            font-size: 1.2rem;
            text-align: center;
            width: 150px;
            margin-bottom: 10px;
            text-transform: uppercase;
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid var(--accent);
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 10px auto;
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

    </style>
</head>
<body>

    <div id="header">
        <div class="top-row">
            <div class="brand-section">
                <h1>CHAIN REACTION</h1>
            </div>
            <div class="action-buttons">
                <button id="online-menu-btn" class="primary">Play Online</button>
                <button id="restart-btn" class="icon-btn" title="Restart Game">&#8635;</button>
            </div>
        </div>
        <div class="controls-row" id="local-controls">
            <div class="settings-group">
                <select id="player-select">
                    <option value="2">2 Players</option>
                    <option value="3">3 Players</option>
                    <option value="4">4 Players</option>
                    <option value="5">5 Players</option>
                    <option value="6">6 Players</option>
                </select>

                <select id="grid-select">
                    <option value="small">Small</option>
                    <option value="medium" selected>Medium</option>
                    <option value="large">Large</option>
                    <option value="xlarge">XL</option>
                </select>

                <label>
                    <input type="checkbox" id="ai-toggle"> AI
                </label>
            </div>
        </div>
        <div id="online-status" style="display:none; font-size: 0.7rem; color: var(--accent); letter-spacing: 1px;">
            ONLINE: <span id="online-room-id">---</span>
        </div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div id="status-bar">
        <div class="turn-indicator">
            <span id="current-turn-text">Red's Turn</span>
        </div>
        <a href="https://kaiross.in" target="_blank" rel="noopener" class="brand-link">KAIROSS.IN</a>
    </div>

    <!-- Win Modal -->
    <div id="win-modal" class="modal">
        <h2 id="winner-text">Red Wins!</h2>
        <button id="play-again-btn">Play Again</button>
        <button id="exit-online-btn" style="display:none; margin-top:10px;">Exit to Lobby</button>
    </div>

    <!-- Online Lobby Modal -->
    <div id="lobby-modal" class="modal">
        <div class="modal-content">
            <h2>Online Lobby</h2>
            <div id="lobby-main">
                <div class="modal-btn-group">
                    <button id="auto-match-btn" class="primary">Auto Match</button>
                    <button id="create-room-btn">Create Private Room</button>
                    <button id="join-room-btn">Join via Code</button>
                    <button id="cancel-lobby-btn">Back to Local</button>
                </div>
            </div>

            <!-- Join Room UI -->
            <div id="lobby-join" style="display:none;">
                <p>Enter 4-Digit Room Code</p>
                <input type="text" id="room-code-input" class="room-input" maxlength="4" placeholder="ABCD">
                <div class="modal-btn-group">
                    <button id="confirm-join-btn" class="primary">Join</button>
                    <button id="back-to-main-btn">Back</button>
                </div>
                <p id="join-error" style="color:red; font-size:0.8rem; margin-top:5px;"></p>
            </div>

            <!-- Waiting UI -->
            <div id="lobby-waiting" style="display:none;">
                <p id="waiting-msg">Looking for opponent...</p>
                <div class="room-code-display" id="display-room-code" style="display:none;"></div>
                <div class="loading-spinner"></div>
                <button id="cancel-waiting-btn" style="margin-top:20px;">Cancel</button>
            </div>
        </div>
    </div>

<script>
    // --- Socket.io Connection ---
    const socket = io({
        transports: ['websocket', 'polling'],
        upgrade: true
    });

    socket.on('connect', () => {
        console.log('Connected to server:', socket.id);
    });

    socket.on('disconnect', () => {
        console.log('Disconnected from server');
    });

    socket.on('connect_error', (error) => {
        console.error('Connection error:', error);
    });

    // --- Game Code ---

    const COLORS = [
        '#FF3B30', '#32D74B', '#0A84FF', '#FFD60A', '#BF5AF2', '#64D2FF', '#FF9F0A', '#FF375F'
    ];
    const DARK_COLORS = COLORS.map(c => adjustColor(c, -60));

    function adjustColor(color, amount) {
        return '#' + color.replace(/^#/, '').replace(/../g, color => ('0'+Math.min(255, Math.max(0, parseInt(color, 16) + amount)).toString(16)).substr(-2));
    }

    function hexToRgba(hex, alpha) {
        let r = parseInt(hex.slice(1, 3), 16);
        let g = parseInt(hex.slice(3, 5), 16);
        let b = parseInt(hex.slice(5, 7), 16);
        return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function generateRoomCode() {
        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
        let code = '';
        for (let i = 0; i < 4; i++) code += chars.charAt(Math.floor(Math.random() * chars.length));
        return code;
    }

    class SoundManager {
        constructor() {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.masterGain = this.ctx.createGain();
            this.masterGain.gain.value = 0.3;
            this.masterGain.connect(this.ctx.destination);
            this.noiseBuffer = this.createNoiseBuffer();
        }
        createNoiseBuffer() {
            const bufferSize = this.ctx.sampleRate * 2;
            const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            return buffer;
        }
        resume() { if (this.ctx.state === 'suspended') this.ctx.resume(); }
        playTone(freq, type, duration, startTime = 0) {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime + startTime);
            gain.gain.setValueAtTime(1, this.ctx.currentTime + startTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + startTime + duration);
            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.start(this.ctx.currentTime + startTime);
            osc.stop(this.ctx.currentTime + startTime + duration);
        }
        playPop() {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.frequency.setValueAtTime(800, this.ctx.currentTime);
            osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.1);
            gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.1);
        }
        playWhoosh() {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(200, this.ctx.currentTime);
            osc.frequency.linearRampToValueAtTime(50, this.ctx.currentTime + 0.2);
            gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.2);
            osc.connect(gain);
            gain.connect(this.masterGain);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.2);
        }
        playExplosion() {
            const noise = this.ctx.createBufferSource();
            noise.buffer = this.noiseBuffer;
            const noiseFilter = this.ctx.createBiquadFilter();
            noiseFilter.type = 'lowpass';
            noiseFilter.frequency.setValueAtTime(1000, this.ctx.currentTime);
            noiseFilter.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.3);
            const noiseGain = this.ctx.createGain();
            noiseGain.gain.setValueAtTime(0.8, this.ctx.currentTime);
            noiseGain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(this.masterGain);
            noise.start();
            noise.stop(this.ctx.currentTime + 0.4);
            this.playTone(60, 'square', 0.3);
        }
        playWin() {
            const base = 440;
            [0, 4, 7, 12, 16, 19].forEach((semitone, i) => {
                const freq = base * Math.pow(2, semitone/12);
                this.playTone(freq, 'triangle', 0.6, i * 0.08);
            });
        }
    }

    // --- Online Manager (Socket.io) ---
    class OnlineManager {
        constructor(game) {
            this.game = game;
            this.playerIndex = -1;
            this.roomCode = null;
            this.setupSocketListeners();
        }

        setupSocketListeners() {
            // Waiting for opponent
            socket.on('waiting', (data) => {
                document.getElementById('lobby-main').style.display = 'none';
                document.getElementById('lobby-waiting').style.display = 'block';
                document.getElementById('waiting-msg').innerText = data.message;
            });

            // Room created (private)
            socket.on('room-created', (data) => {
                this.roomCode = data.roomCode;
                document.getElementById('lobby-main').style.display = 'none';
                document.getElementById('lobby-waiting').style.display = 'block';
                document.getElementById('waiting-msg').innerText = "Waiting for friend...";
                const codeDisplay = document.getElementById('display-room-code');
                codeDisplay.innerText = data.roomCode;
                codeDisplay.style.display = 'block';
            });

            // Game started
            socket.on('game-start', (data) => {
                this.playerIndex = data.playerIndex;
                this.roomCode = data.roomCode;

                document.getElementById('lobby-modal').classList.remove('active');
                this.game.startOnlineGame(data.playerIndex, data.grid);
                document.getElementById('online-room-id').innerText = data.roomCode;
                document.getElementById('online-status').style.display = 'block';
                document.getElementById('local-controls').style.display = 'none';
            });

            // Move received from server
            socket.on('move-made', (data) => {
                this.game.applyOnlineMove(data);
            });

            // Game over
            socket.on('game-over', (data) => {
                this.game.triggerWin(data.winner);
            });

            // Opponent disconnected
            socket.on('opponent-disconnected', () => {
                alert('Opponent disconnected. You win!');
                this.game.triggerWin(this.playerIndex);
            });

            // Error handling
            socket.on('error', (data) => {
                console.error('Server error:', data.message);
                document.getElementById('join-error').innerText = data.message;
            });

            // Waiting cancelled
            socket.on('waiting-cancelled', () => {
                document.getElementById('lobby-main').style.display = 'block';
                document.getElementById('lobby-waiting').style.display = 'none';
            });

            // Room expired
            socket.on('room-expired', () => {
                alert('Room expired due to inactivity');
                this.cleanup();
            });
        }

        autoMatch() {
            socket.emit('auto-match');
        }

        createGame(isPrivate) {
            if (isPrivate) {
                socket.emit('create-room');
            } else {
                socket.emit('auto-match');
            }
        }

        joinGameByCode(code) {
            document.getElementById('join-error').innerText = '';
            socket.emit('join-room', { roomCode: code.toUpperCase() });
        }

        sendMove(r, c) {
            socket.emit('move', { r, c });
        }

        cancelWaiting() {
            socket.emit('cancel-waiting');
        }

        cleanup() {
            socket.emit('leave-room');
            this.playerIndex = -1;
            this.roomCode = null;
            document.getElementById('online-status').style.display = 'none';
            document.getElementById('local-controls').style.display = 'flex';
        }
    }

    // --- Advanced AI Logic ---

    // Helper: Deep Copy Grid
    function cloneGrid(grid) {
        return grid.map(row => row.map(cell => ({...cell})));
    }

    // Helper: Simulate entire chain reaction for a move
    function simulateChainReaction(initialGrid, r, c, playerIdx, rows, cols) {
        let grid = cloneGrid(initialGrid);

        // Apply Initial Move
        grid[r][c].owner = playerIdx;
        grid[r][c].count++;

        let unstable = true;
        let loops = 0;

        // Iterative simulation (mathematical, no animation delays)
        while (unstable && loops < 100) { // limit loops to prevent infinite freeze
            unstable = false;
            loops++;

            // Find Criticals
            let criticals = [];
            for (let i = 0; i < rows; i++) {
                for (let j = 0; j < cols; j++) {
                    if (grid[i][j].count >= grid[i][j].criticalMass) {
                        criticals.push({r: i, c: j, owner: grid[i][j].owner});
                    }
                }
            }

            if (criticals.length > 0) unstable = true;

            // Explode
            for (let crit of criticals) {
                grid[crit.r][crit.c].count -= grid[crit.r][crit.c].criticalMass;
                if (grid[crit.r][crit.c].count === 0) grid[crit.r][crit.c].owner = null;

                const dirs = [{dr:-1,dc:0}, {dr:1,dc:0}, {dr:0,dc:-1}, {dr:0,dc:1}];
                for (let d of dirs) {
                    let nr = crit.r + d.dr;
                    let nc = crit.c + d.dc;
                    if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
                        grid[nr][nc].owner = crit.owner; // Capture
                        grid[nr][nc].count++;
                    }
                }
            }
        }
        return grid;
    }

    // Helper: Heuristic Evaluation
    function evaluateGrid(grid, playerIdx, rows, cols) {
        let score = 0;
        let myOrbs = 0;
        let enemyOrbs = 0;
        let activeEnemies = new Set();

        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                const cell = grid[r][c];
                if (cell.owner === playerIdx) {
                    myOrbs += cell.count;
                    score += cell.count * 10; // Value per orb
                    if (cell.count === cell.criticalMass - 1) score += 20; // Critical waiting
                } else if (cell.owner !== null) {
                    enemyOrbs += cell.count;
                    activeEnemies.add(cell.owner);
                    score -= cell.count * 10;
                    if (cell.count === cell.criticalMass - 1) score -= 25; // Danger
                }
            }
        }

        // Win/Loss Condition
        if (enemyOrbs === 0 && myOrbs > 0) return 10000; // Win
        if (myOrbs === 0 && enemyOrbs > 0) return -10000; // Loss

        return score;
    }

    // Helper: Get Valid Moves
    function getValidMoves(grid, playerIdx, rows, cols) {
        let moves = [];
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                if (grid[r][c].owner === null || grid[r][c].owner === playerIdx) {
                    moves.push({r, c});
                }
            }
        }
        return moves;
    }

    // Minimax Function
    function minimax(grid, depth, isMaximizing, playerIdx, rows, cols) {
        // Simple end check
        const score = evaluateGrid(grid, playerIdx, rows, cols);
        if (Math.abs(score) >= 5000 || depth === 0) {
            return score;
        }

        // Opponent Index (Assuming 2 player for AI mode)
        const opponentIdx = (playerIdx + 1) % 2;
        const moves = getValidMoves(grid, isMaximizing ? playerIdx : opponentIdx, rows, cols);

        if (moves.length === 0) return isMaximizing ? -10000 : 10000;

        if (isMaximizing) {
            let maxEval = -Infinity;
            // Limit moves to top candidates to save performance?
            // For now, full search on small depth
            for (let move of moves) {
                const newGrid = simulateChainReaction(grid, move.r, move.c, playerIdx, rows, cols);
                const evalScore = minimax(newGrid, depth - 1, false, playerIdx, rows, cols);
                maxEval = Math.max(maxEval, evalScore);
            }
            return maxEval;
        } else {
            let minEval = Infinity;
            for (let move of moves) {
                const newGrid = simulateChainReaction(grid, move.r, move.c, opponentIdx, rows, cols);
                const evalScore = minimax(newGrid, depth - 1, true, playerIdx, rows, cols);
                minEval = Math.min(minEval, evalScore);
            }
            return minEval;
        }
    }


    // --- Game Engine ---

    class Game {
        constructor(canvasId, playerCount, gridSize, isVsCpu) {
            this.canvas = document.getElementById(canvasId);
            this.ctx = this.canvas.getContext('2d');
            this.defaultPlayerCount = playerCount;
            this.defaultGridSize = gridSize;
            this.isVsCpu = isVsCpu;

            this.onlineManager = new OnlineManager(this);
            this.isOnline = false;
            this.myOnlineIndex = -1;
            this.lastProcessedMoveId = null;

            if (!window.soundManager) window.soundManager = new SoundManager();

            this.setupGame(playerCount, gridSize);

            this.resize();
            window.addEventListener('resize', () => this.resize());

            this.canvas.addEventListener('mousedown', (e) => this.handleInput(e.clientX, e.clientY));
            this.canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                this.handleInput(e.touches[0].clientX, e.touches[0].clientY);
            }, { passive: false });

            this.lastTime = 0;
            requestAnimationFrame((t) => this.loop(t));
            this.updateUI();
        }

        setupGame(playerCount, gridSize) {
            this.playerCount = playerCount;
            // UPDATED GRID SIZES - DOUBLING PROGRESSION
            switch(gridSize) {
                case 'small': this.gridRows = 6; this.gridCols = 4; break; // 24 cells
                case 'medium': this.gridRows = 8; this.gridCols = 6; break; // 48 cells (Double)
                case 'large': this.gridRows = 12; this.gridCols = 8; break; // 96 cells (Double)
                case 'xlarge': this.gridRows = 16; this.gridCols = 12; break; // 192 cells (Double)
                default: this.gridRows = 8; this.gridCols = 6; break;
            }

            this.currentPlayerIndex = 0;
            this.isAnimating = false;
            this.projectiles = [];
            this.gameOver = false;
            this.playersAlive = new Array(playerCount).fill(true);

            this.grid = [];
            for (let r = 0; r < this.gridRows; r++) {
                let row = [];
                for (let c = 0; c < this.gridCols; c++) {
                    row.push({
                        row: r, col: c, count: 0, owner: null,
                        criticalMass: this.getCriticalMass(r, c),
                        rotationOffset: Math.random() * Math.PI * 2
                    });
                }
                this.grid.push(row);
            }
        }

        startOnlineGame(myIndex, serverGrid) {
            this.isOnline = true;
            this.myOnlineIndex = myIndex;
            this.setupGame(2, 'medium');

            // Sync grid from server
            if (serverGrid) {
                for (let r = 0; r < this.gridRows; r++) {
                    for (let c = 0; c < this.gridCols; c++) {
                        this.grid[r][c].count = serverGrid[r][c].count;
                        this.grid[r][c].owner = serverGrid[r][c].owner;
                    }
                }
            }

            this.resize();
            this.updateUI();
        }

        getCriticalMass(r, c) {
            let n = 0;
            if (r > 0) n++; if (r < this.gridRows - 1) n++;
            if (c > 0) n++; if (c < this.gridCols - 1) n++;
            return n;
        }

        resize() {
            const c = document.getElementById('game-container');
            const w = c.clientWidth - 20;
            const h = c.clientHeight - 20;

            // Calculate logical dimensions
            const cellW = Math.floor(w / this.gridCols);
            const cellH = Math.floor(h / this.gridRows);
            this.cellSize = Math.min(cellW, cellH, 60);

            const logicalWidth = this.cellSize * this.gridCols;
            const logicalHeight = this.cellSize * this.gridRows;

            // High DPI (Retina) Scaling for Anti-Aliasing
            const dpr = window.devicePixelRatio || 1;
            this.canvas.width = logicalWidth * dpr;
            this.canvas.height = logicalHeight * dpr;

            // Set CSS size to logical dimensions
            this.canvas.style.width = `${logicalWidth}px`;
            this.canvas.style.height = `${logicalHeight}px`;

            // Scale the drawing context so our logic uses logical coordinates
            this.ctx.scale(dpr, dpr);
        }

        handleInput(clientX, clientY) {
            window.soundManager.resume();
            if (this.gameOver || this.isAnimating || this.projectiles.length > 0) return;

            if (this.isVsCpu && this.currentPlayerIndex === 1) return;
            if (this.isOnline && this.currentPlayerIndex !== this.myOnlineIndex) return;

            const rect = this.canvas.getBoundingClientRect();
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            const c = Math.floor(x / this.cellSize);
            const r = Math.floor(y / this.cellSize);

            if (r >= 0 && r < this.gridRows && c >= 0 && c < this.gridCols) {
                this.attemptMove(r, c);
            }
        }

        attemptMove(r, c) {
            const cell = this.grid[r][c];

            if (cell.owner === null || cell.owner === this.currentPlayerIndex) {
                if (this.isOnline) {
                    // Only send to server, don't execute locally
                    // Server will validate and broadcast back
                    this.onlineManager.sendMove(r, c);
                } else {
                    this.executeMove(r, c, this.currentPlayerIndex);
                }
            }
        }

        executeMove(r, c, playerIdx) {
            const cell = this.grid[r][c];
            cell.owner = playerIdx;
            cell.count++;
            window.soundManager.playPop();
            this.checkExplosions();

            if (!this.isAnimating && this.projectiles.length === 0) {
                this.endTurn();
            }
        }

        applyOnlineMove(moveData) {
            // Sync entire grid state from server (authoritative)
            for (let r = 0; r < this.gridRows; r++) {
                for (let c = 0; c < this.gridCols; c++) {
                    this.grid[r][c].count = moveData.grid[r][c].count;
                    this.grid[r][c].owner = moveData.grid[r][c].owner;
                }
            }

            // Update turn
            this.currentPlayerIndex = moveData.currentTurn;

            // Play sound for the move
            window.soundManager.playPop();

            // Check win condition
            this.checkWinCondition();

            // Update UI
            this.updateUI();
        }

        checkExplosions() {
            let unstable = false;
            for (let r = 0; r < this.gridRows; r++) {
                for (let c = 0; c < this.gridCols; c++) {
                    let cell = this.grid[r][c];
                    if (cell.count >= cell.criticalMass) {
                        const explosionColor = cell.owner;
                        cell.count -= cell.criticalMass;
                        if (cell.count === 0) cell.owner = null;
                        this.createExplosion(r, c, explosionColor);
                        unstable = true;
                    }
                }
            }
            if (unstable) {
                if (!this.isAnimating) window.soundManager.playExplosion();
                this.isAnimating = true;
            }
        }

        createExplosion(r, c, color) {
            const dirs = [{dr:-1,dc:0}, {dr:1,dc:0}, {dr:0,dc:-1}, {dr:0,dc:1}];
            dirs.forEach(d => {
                const nr = r + d.dr, nc = c + d.dc;
                if (nr >= 0 && nr < this.gridRows && nc >= 0 && nc < this.gridCols) {
                    this.projectiles.push({
                        x: c * this.cellSize + this.cellSize/2,
                        y: r * this.cellSize + this.cellSize/2,
                        targetR: nr, targetC: nc,
                        targetX: nc * this.cellSize + this.cellSize/2,
                        targetY: nr * this.cellSize + this.cellSize/2,
                        color: color,
                        speed: 4 // SLOWED DOWN from 12 for improved feel
                    });
                    window.soundManager.playWhoosh(); // NEW SOUND
                }
            });
        }

        update() {
            const arrived = [];
            for (let i = this.projectiles.length - 1; i >= 0; i--) {
                let p = this.projectiles[i];
                const dx = p.targetX - p.x, dy = p.targetY - p.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                if (dist < p.speed) {
                    p.x = p.targetX; p.y = p.targetY;
                    arrived.push(p);
                    this.projectiles.splice(i, 1);
                } else {
                    p.x += (dx/dist) * p.speed;
                    p.y += (dy/dist) * p.speed;
                }
            }

            if (arrived.length > 0) {
                arrived.forEach(p => {
                    let cell = this.grid[p.targetR][p.targetC];
                    cell.owner = p.color;
                    cell.count++;
                });
                this.checkExplosions();
            }

            if (this.isAnimating && this.projectiles.length === 0) {
                this.isAnimating = false;
                this.checkWinCondition();
                if (!this.gameOver) this.endTurn();
            }
        }

        endTurn() {
            let loopCount = 0;
            do {
                this.currentPlayerIndex = (this.currentPlayerIndex + 1) % this.playerCount;
                loopCount++;
            } while (!this.playersAlive[this.currentPlayerIndex] && loopCount <= this.playerCount);

            this.updateUI();

            if (this.isVsCpu && this.currentPlayerIndex === 1 && !this.gameOver) {
                this.makeAIMove();
            }
        }

        makeAIMove() {
            if (this.gameOver) return;

            // Use Minimax to find best move
            const moves = getValidMoves(this.grid, 1, this.gridRows, this.gridCols);
            if (moves.length === 0) return;

            let bestScore = -Infinity;
            let bestMove = moves[Math.floor(Math.random() * moves.length)]; // default random

            // Optimize: If too many moves, just use heuristic sort, otherwise use Minimax
            // For performance in JS single thread, we limit depth
            // Depth 1 = look at result of my move (simulation)
            // Depth 2 = look at result of my move + opponent's best counter

            const depth = 1; // Depth 1 is actually quite strong with full chain simulation

            // Shuffle moves to add variety if scores are equal
            moves.sort(() => Math.random() - 0.5);

            for (let move of moves) {
                // Simulate the move
                const simGrid = simulateChainReaction(this.grid, move.r, move.c, 1, this.gridRows, this.gridCols);
                const score = evaluateGrid(simGrid, 1, this.gridRows, this.gridCols);

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }

            setTimeout(() => {
                if (!this.gameOver) this.attemptMove(bestMove.r, bestMove.c);
            }, 500);
        }

        checkWinCondition() {
            let orbCounts = new Array(this.playerCount).fill(0);
            let totalOrbs = 0;
            for(let r=0; r<this.gridRows; r++){
                for(let c=0; c<this.gridCols; c++){
                    if(this.grid[r][c].owner !== null) {
                        orbCounts[this.grid[r][c].owner]++;
                        totalOrbs++;
                    }
                }
            }

            if (totalOrbs >= this.playerCount) {
                 for(let i=0; i<this.playerCount; i++) {
                    if (orbCounts[i] === 0) this.playersAlive[i] = false;
                 }
            }

            let aliveCount = this.playersAlive.filter(Boolean).length;
            if (aliveCount === 1 && totalOrbs > 1) {
                this.triggerWin(this.playersAlive.indexOf(true));
            }
        }

        triggerWin(playerIndex) {
            this.gameOver = true;
            window.soundManager.playWin();
            const modal = document.getElementById('win-modal');
            const text = document.getElementById('winner-text');

            let winText = `Player ${playerIndex + 1} Wins!`;
            if (this.isVsCpu && playerIndex === 1) winText = "Computer Wins!";
            if (this.isOnline) {
                winText = playerIndex === this.myOnlineIndex ? "YOU WIN!" : "YOU LOSE!";
                document.getElementById('exit-online-btn').style.display = 'inline-block';
                document.getElementById('play-again-btn').style.display = 'none';
            } else {
                document.getElementById('exit-online-btn').style.display = 'none';
                document.getElementById('play-again-btn').style.display = 'inline-block';
            }

            text.innerText = winText;
            text.style.color = COLORS[playerIndex];
            modal.classList.add('active');
        }

        updateUI() {
            const bar = document.getElementById('status-bar');
            const text = document.getElementById('current-turn-text');
            const color = COLORS[this.currentPlayerIndex];

            let playerLabel = `Player ${this.currentPlayerIndex + 1}`;
            if (this.isVsCpu && this.currentPlayerIndex === 1) playerLabel = "Computer";
            if (this.isOnline) {
                playerLabel = this.currentPlayerIndex === this.myOnlineIndex ? "YOUR TURN" : "OPPONENT'S TURN";
            }

            text.innerHTML = `<span class="player-dot" style="background:${color}; box-shadow: 0 0 8px ${color}"></span> ${playerLabel}`;
            bar.style.borderTopColor = color;
            this.canvas.style.borderColor = adjustColor(color, -60);
        }

        draw(time) {
            this.ctx.fillStyle = '#121212';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

            const gridColor = COLORS[this.currentPlayerIndex];
            this.ctx.strokeStyle = hexToRgba(gridColor, 0.3);
            this.ctx.lineWidth = 1;
            this.ctx.beginPath();
            for (let i = 0; i <= this.gridCols; i++) {
                this.ctx.moveTo(i * this.cellSize, 0);
                this.ctx.lineTo(i * this.cellSize, this.canvas.height);
            }
            for (let i = 0; i <= this.gridRows; i++) {
                this.ctx.moveTo(0, i * this.cellSize);
                this.ctx.lineTo(this.canvas.width, i * this.cellSize);
            }
            this.ctx.stroke();

            for (let r = 0; r < this.gridRows; r++) {
                for (let c = 0; c < this.gridCols; c++) this.drawCell(r, c, time);
            }

            this.projectiles.forEach(p => {
                this.ctx.fillStyle = COLORS[p.color];
                this.ctx.beginPath();
                this.ctx.arc(p.x, p.y, this.cellSize * 0.15, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.shadowBlur = 10;
                this.ctx.shadowColor = COLORS[p.color];
                this.ctx.fill();
                this.ctx.shadowBlur = 0;
            });
        }

        drawCell(r, c, time) {
            const cell = this.grid[r][c];
            if (cell.count === 0) return;

            const cx = c * this.cellSize + this.cellSize / 2;
            const cy = r * this.cellSize + this.cellSize / 2;
            const color = COLORS[cell.owner];
            const radius = this.cellSize * 0.18;
            const t = time * 0.002 + cell.rotationOffset;

            this.ctx.fillStyle = color;
            this.ctx.shadowBlur = 15;
            this.ctx.shadowColor = color;

            if (cell.count === 1) {
                this.drawOrb(cx + Math.cos(t*2)*2, cy + Math.sin(t*2)*2, radius, color);
            }
            else if (cell.count === 2) {
                const dist = this.cellSize * 0.15;
                this.drawOrb(cx + Math.cos(t)*dist, cy + Math.sin(t)*dist, radius, color);
                this.drawOrb(cx + Math.cos(t+Math.PI)*dist, cy + Math.sin(t+Math.PI)*dist, radius, color);
            }
            else if (cell.count === 3) {
                const dist = this.cellSize * 0.15;
                const step = (Math.PI * 2) / 3;
                this.drawOrb(cx + Math.cos(t)*dist, cy + Math.sin(t)*dist, radius, color);
                this.drawOrb(cx + Math.cos(t+step)*dist, cy + Math.sin(t+step)*dist, radius, color);
                this.drawOrb(cx + Math.cos(t+step*2)*dist, cy + Math.sin(t+step*2)*dist, radius, color);
            }
            this.ctx.shadowBlur = 0;
        }

        drawOrb(x, y, r, color) {
            this.ctx.beginPath();
            this.ctx.arc(x, y, r, 0, Math.PI * 2);
            const grad = this.ctx.createRadialGradient(x - r/3, y - r/3, r/6, x, y, r);
            // Reduced reflection: Use lighter shade of color instead of pure white (#fff)
            grad.addColorStop(0, adjustColor(color, 100));
            grad.addColorStop(0.5, color);
            grad.addColorStop(1, adjustColor(color, -50));
            this.ctx.fillStyle = grad;
            this.ctx.fill();
        }

        loop(time) {
            this.update();
            this.draw(time);
            requestAnimationFrame((t) => this.loop(t));
        }

        restart(online = false) {
            if (!online) {
                this.onlineManager.cleanup();
                this.isOnline = false;
                const pCount = parseInt(document.getElementById('player-select').value);
                const gSize = document.getElementById('grid-select').value;
                this.isVsCpu = document.getElementById('ai-toggle').checked;
                this.setupGame(this.isVsCpu ? 2 : pCount, gSize);
                this.resize(); // FIXED: Ensure canvas resizes immediately
                this.updateUI();
            } else {
                // Handled via online manager re-start logic if implemented
            }
            document.getElementById('win-modal').classList.remove('active');
        }
    }

    // --- Initialization ---
    let gameInstance = null;

    function initGame() {
        gameInstance = new Game('gameCanvas', 2, 'medium', false);

        // Event Listeners for new Online UI
        document.getElementById('online-menu-btn').addEventListener('click', () => {
            document.getElementById('lobby-modal').classList.add('active');
            document.getElementById('lobby-main').style.display = 'block';
            document.getElementById('lobby-join').style.display = 'none';
            document.getElementById('lobby-waiting').style.display = 'none';
        });

        document.getElementById('cancel-lobby-btn').addEventListener('click', () => {
            document.getElementById('lobby-modal').classList.remove('active');
        });

        document.getElementById('auto-match-btn').addEventListener('click', () => {
            gameInstance.onlineManager.autoMatch();
        });

        document.getElementById('create-room-btn').addEventListener('click', () => {
            gameInstance.onlineManager.createGame(true);
        });

        document.getElementById('join-room-btn').addEventListener('click', () => {
            document.getElementById('lobby-main').style.display = 'none';
            document.getElementById('lobby-join').style.display = 'block';
        });

        document.getElementById('confirm-join-btn').addEventListener('click', () => {
            const code = document.getElementById('room-code-input').value;
            if(code.length === 4) {
                gameInstance.onlineManager.joinGameByCode(code);
            }
        });

        document.getElementById('back-to-main-btn').addEventListener('click', () => {
            document.getElementById('lobby-main').style.display = 'block';
            document.getElementById('lobby-join').style.display = 'none';
        });

        document.getElementById('cancel-waiting-btn').addEventListener('click', () => {
             gameInstance.onlineManager.cancelWaiting();
             document.getElementById('lobby-main').style.display = 'block';
             document.getElementById('lobby-waiting').style.display = 'none';
             document.getElementById('display-room-code').style.display = 'none';
        });

        document.getElementById('exit-online-btn').addEventListener('click', () => {
            gameInstance.restart(false);
        });
    }

    document.getElementById('restart-btn').addEventListener('click', () => gameInstance.restart(false));
    document.getElementById('play-again-btn').addEventListener('click', () => gameInstance.restart(false));

    // Dynamic settings change
    document.getElementById('player-select').addEventListener('change', () => gameInstance.restart(false));
    document.getElementById('grid-select').addEventListener('change', () => gameInstance.restart(false));
    document.getElementById('ai-toggle').addEventListener('change', () => gameInstance.restart(false));

    window.onload = initGame;

</script>
</body>
</html>
